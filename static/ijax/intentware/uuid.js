// Generated by CoffeeScript 1.6.3
(function() {
  var BufferClass, i, parse, unparse, uuid, v1, v4, whatwgRNG, _byteToHex, _clockseq, _global, _hexToByte, _lastMSecs, _lastNSecs, _nodeId, _previousRoot, _rb, _rnds, _rnds8, _rng, _seedBytes;

  _global = this;

  _rng = void 0;

  if (typeof require === "function") {
    try {
      _rb = require("crypto").randomBytes;
      _rng = _rb && function() {
        return _rb(16);
      };
    } catch (_error) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    _rnds8 = new Uint8Array(16);
    _rng = whatwgRNG = function() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    _rnds = new Array(16);
    _rng = function() {
      var i, r;
      i = 0;
      r = void 0;
      while (i < 16) {
        if ((i & 0x03) === 0) {
          r = Math.random() * 0x100000000;
        }
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        i++;
      }
      return _rnds;
    };
  }

  BufferClass = (typeof Buffer === "function" ? Buffer : Array);

  _byteToHex = [];

  _hexToByte = {};

  i = 0;

  while (i < 256) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
    i++;
  }

  parse = function(s, buf, offset) {
    var ii;
    i = (buf && offset) || 0;
    ii = 0;
    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) {
        return buf[i + ii++] = _hexToByte[oct];
      }
    });
    while (ii < 16) {
      buf[i + ii++] = 0;
    }
    return buf;
  };

  unparse = function(buf, offset) {
    var bth;
    i = offset || 0;
    bth = _byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  };

  _seedBytes = _rng();

  _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

  _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  _lastMSecs = 0;

  _lastNSecs = 0;

  v1 = function(options, buf, offset) {
    var b, clockseq, dt, msecs, n, node, nsecs, tl, tmh;
    i = buf && offset || 0;
    b = buf || [];
    options = options || {};
    clockseq = (options.clockseq != null ? options.clockseq : _clockseq);
    msecs = (options.msecs != null ? options.msecs : new Date().getTime());
    nsecs = (options.nsecs != null ? options.nsecs : _lastNSecs + 1);
    dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
    if (dt < 0 && (options.clockseq == null)) {
      clockseq = clockseq + 1 & 0x3fff;
    }
    if ((dt < 0 || msecs > _lastMSecs) && (options.nsecs == null)) {
      nsecs = 0;
    }
    if (nsecs >= 10000) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;
    tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;
    b[i++] = tmh >>> 24 & 0xf | 0x10;
    b[i++] = tmh >>> 16 & 0xff;
    b[i++] = clockseq >>> 8 | 0x80;
    b[i++] = clockseq & 0xff;
    node = options.node || _nodeId;
    n = 0;
    while (n < 6) {
      b[i + n] = node[n];
      n++;
    }
    if (buf) {
      return buf;
    } else {
      return unparse(b);
    }
  };

  v4 = function(options, buf, offset) {
    var ii, rnds;
    i = buf && offset || 0;
    if (typeof options === "string") {
      buf = (options === "binary" ? new BufferClass(16) : null);
      options = null;
    }
    options = options || {};
    rnds = options.random || (options.rng || _rng)();
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
      ii = 0;
      while (ii < 16) {
        buf[i + ii] = rnds[ii];
        ii++;
      }
    }
    return buf || unparse(rnds);
  };

  uuid = v4;

  uuid.v1 = v1;

  uuid.v4 = v4;

  uuid.parse = parse;

  uuid.unparse = unparse;

  uuid.BufferClass = BufferClass;

  if (typeof define === "function" && define.amd) {
    define(function() {
      return uuid;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = uuid;
  } else {
    _previousRoot = _global.Uuid;
    uuid.noConflict = function() {
      _global.Uuid = _previousRoot;
      return uuid;
    };
    _global.Uuid = _global.exports = uuid;
  }

  uuid.isUuid = function(value) {
    var parsed, unparsed;
    if ((value != null) && Object.prototype.toString.apply(value === '[object String]' && value.length === 36)) {
      parsed = parse(value);
      unparsed = unparse(parsed);
      return value === unparsed;
    } else if (Buffer.isBuffer(value)) {
      return value.length === 16;
    } else {
      return false;
    }
  };

}).call(this);
